<!DOCTYPE html>
<html lang="id">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Downloader ‚Äî Aanz</title>
  <style>
    :root{
      --bg-a:#071126;
      --bg-b:#0b2740;
      --card:#071a2b;
      --accent:#4cc9f0;
      --muted:rgba(255,255,255,0.7);
      --glass: rgba(255,255,255,0.03);
      --radius:14px;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family:Inter,ui-sans-serif,system-ui,-apple-system,"Segoe UI",Roboto,Arial;
      background: linear-gradient(135deg,var(--bg-a),var(--bg-b));
      color:#eaf6ff;
      min-height:100vh;
      display:flex;
      align-items:center;
      justify-content:center;
      padding:28px;
    }
    .wrap{
      width:100%;
      max-width:920px;
      border-radius:18px;
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      box-shadow: 0 18px 60px rgba(2,8,23,0.7);
      padding:28px;
      border: 1px solid rgba(255,255,255,0.04);
      backdrop-filter: blur(10px);
    }
    header{display:flex;align-items:center;gap:16px;margin-bottom:14px}
    .logo{
      width:64px;height:64px;border-radius:14px;
      background:linear-gradient(135deg,var(--accent),#6b8cff);
      display:flex;align-items:center;justify-content:center;font-weight:800;color:#021226;
      box-shadow: 0 8px 28px rgba(76,201,240,0.12);
      font-size:20px;
    }
    h1{font-size:22px;margin:0;color:#e6fbff}
    p.sub{margin:2px 0 0;color:var(--muted);font-size:13px}
    .grid{display:grid;grid-template-columns:1fr 360px;gap:18px;margin-top:18px}
    .card{
      background: rgba(255,255,255,0.02);
      border-radius:12px;
      padding:16px;
      border:1px solid rgba(255,255,255,0.03);
    }
    .controls{display:flex;gap:12px;align-items:center}
    input[type="text"]{
      flex:1;padding:12px;border-radius:10px;border:1px solid rgba(255,255,255,0.06);
      background:var(--glass); color:inherit; outline:none; font-size:14px;
    }
    button.btn{
      padding:11px 14px;border-radius:10px;border:none;background:linear-gradient(90deg,var(--accent),#6b8cff);
      color:#031125;font-weight:700; cursor:pointer; box-shadow: 0 10px 28px rgba(76,201,240,0.12);
    }
    .preview{
      width:100%;border-radius:10px;overflow:hidden;background:#000;
      display:flex;align-items:center;justify-content:center;min-height:240px;
    }
    .preview img, .preview video { width:100%; height:auto; display:block; }
    .meta{font-size:13px;color:var(--muted);margin-top:10px}
    .actions{display:flex;gap:12px;margin-top:14px}
    .action-btn{flex:1;padding:10px;border-radius:10px;background:#07233a;color:#eaf6ff;text-align:center;cursor:pointer;border:1px solid rgba(255,255,255,0.03)}
    .action-btn:hover{transform:translateY(-3px); transition:all .18s ease}
    footer{margin-top:18px;text-align:center;color:rgba(255,255,255,0.6);font-size:13px}
    @media(max-width:880px){ .grid{grid-template-columns:1fr} }
  </style>
</head>
<body>
  <div class="wrap" role="main">
    <header>
      <div class="logo">&lt;/&gt;</div>
      <div>
        <h1>All-in-One Downloader</h1>
        <p class="sub">Tempel link TikTok lalu tekan <strong>Fetch</strong>. Preview & tombol download tersedia di sebelah kanan.</p>
      </div>
    </header>

    <div class="grid">
      <div class="card">
        <div style="display:flex;flex-direction:column;gap:12px">
          <div class="controls">
            <input id="urlInput" type="text" placeholder="Masukkan link TikTok..." value="https://www.tiktok.com/@mudafme81/video/7534959343813332229?_r=1&_t=ZS-8zdOM9t6Hg2">
            <button id="btnFetch" class="btn">Fetch</button>
          </div>

          <div id="previewBox" class="preview" aria-live="polite">
            <div style="text-align:center;color:var(--muted)">
              Hasil akan muncul di sini
            </div>
          </div>

          <div class="meta" id="metaText">‚Äî</div>

          <div class="actions">
            <div id="btnDownload" class="action-btn" style="display:none">‚¨áÔ∏è Download File</div>
            <div id="btnOpen" class="action-btn" style="display:none">üîó Buka di Tab Baru</div>
          </div>
        </div>
      </div>

      <aside class="card">
        <strong>Info</strong>
        <p class="meta" style="margin-top:8px">Website ini menggunakan endpoint penyedia downloader. Jika fetch gagal (CORS/Cloudflare), jalankan lewat server/proxy.</p>

        <div style="margin-top:12px">
          <label style="font-size:13px;color:var(--muted)">Nama file hasil</label>
          <input id="filename" type="text" value="tiktok_video.mp4" style="width:100%;padding:10px;border-radius:8px;margin-top:6px;background:transparent;border:1px solid rgba(255,255,255,0.04);color:inherit">
        </div>

        <div style="margin-top:12px">
          <button id="btnTryProxy" class="action-btn">Coba Gunakan Proxy</button>
        </div>
      </aside>
    </div>

    <footer>&lt;/&gt; 2025 Aanz</footer>
  </div>

  <script>
    // Endpoint yang kamu kasih (full): langsung dipakai
    const PROVIDED_ENDPOINT = 'https://api.sxtream.xyz/downloader/aio?url=https%3A%2F%2Fwww.tiktok.com%2F%40mudafme81%2Fvideo%2F7534959343813332229%3F_r%3D1%26_t%3DZS-8zdOM9t6Hg2';
    // We'll use this as base; but users can paste custom URL.
    // If you prefer to use user-provided URL concatenation, we can switch to building query param.

    const btnFetch = document.getElementById('btnFetch');
    const urlInput = document.getElementById('urlInput');
    const previewBox = document.getElementById('previewBox');
    const metaText = document.getElementById('metaText');
    const btnDownload = document.getElementById('btnDownload');
    const btnOpen = document.getElementById('btnOpen');
    const filenameInput = document.getElementById('filename');
    const btnTryProxy = document.getElementById('btnTryProxy');

    let lastBlob = null;
    let lastUrl = null;
    let lastIsBlob = false;
    let useProxy = false;

    btnFetch.addEventListener('click', async () => {
      clearState();
      setLoading(true);

      // Use the exact provided endpoint if input matches sample; else build query
      let fetchUrl;
      try {
        const inputVal = urlInput.value.trim();
        // if input matches the provided sample, use PROVIDED_ENDPOINT directly (avoids double-encoding)
        if (inputVal && (inputVal.includes('mudafme81') || inputVal === PROVIDED_ENDPOINT || inputVal.startsWith('https://api.sxtream.xyz/downloader/aio'))) {
          // if user pasted the raw encoded API URL, use it; else construct using provided endpoint base with user's URL encoded
          if (inputVal.startsWith('https://api.sxtream.xyz/downloader/aio')) {
            fetchUrl = inputVal;
          } else {
            // build aio endpoint using the user's URL encoded
            fetchUrl = 'https://api.sxtream.xyz/downloader/aio?url=' + encodeURIComponent(inputVal);
          }
        } else {
          // fallback: build endpoint
          fetchUrl = 'https://api.sxtream.xyz/downloader/aio?url=' + encodeURIComponent(inputVal || urlInput.value);
        }
      } catch (e) {
        fetchUrl = PROVIDED_ENDPOINT;
      }

      if (useProxy) {
        fetchUrl = 'https://corsproxy.io/?' + encodeURIComponent(fetchUrl);
      }

      try {
        const resp = await fetch(fetchUrl);
        if (!resp.ok) throw new Error('HTTP ' + resp.status);

        const ctype = (resp.headers.get('content-type') || '').toLowerCase();

        // If returns JSON, try find video URL(s)
        if (ctype.includes('application/json')) {
          const j = await resp.json();
          // try common locations used by previous sxtream responses
          const candidates = [
            j.result && j.result.video && j.result.video.noWatermark,
            j.result && j.result.video && j.result.video.watermark,
            j.downloadUrl,
            j.url,
            j.video && j.video.noWatermark,
            j.data && j.data.play,
            j.data && j.data.nowm,
            j.result && j.result.downloadUrl,
          ].flatMap(Boolean);
          const found = candidates.length ? candidates[0] : null;
          if (!found) {
            previewBox.innerHTML = `<div style="padding:18px;color:#f1b0b0">Hasil diterima tapi tidak ditemukan link video.</div>`;
            metaText.textContent = 'Response JSON (tidak ada link video)';
            setLoading(false);
            return;
          }
          // fetch the actual video resource as blob (so we can force download)
          metaText.textContent = 'Sukses: link video ditemukan';
          await fetchAndPreviewResource(found, ctypeGuessFromUrl(found));
        }
        // If binary (image/video), get blob directly
        else if (ctype.startsWith('image/') || ctype.startsWith('video/') || ctype.includes('octet-stream')) {
          const blob = await resp.blob();
          lastBlob = blob;
          lastIsBlob = true;
          lastUrl = URL.createObjectURL(blob);
          renderPreviewByContentType(ctype, lastUrl);
          metaText.textContent = `Sukses (${ctype})`;
          enableActions(true);
        }
        // Other types (HTML) ‚Äî probably blocked by Cloudflare
        else {
          const t = await resp.text();
          previewBox.innerHTML = `<div style="padding:16px;color:#ffc7c7">Respons bukan media (mungkin diblokir). Coba gunakan opsi proxy.</div>`;
          metaText.textContent = 'Respons non-media ‚Äî coba proxy';
          console.warn('Non-media response:', t.slice(0,400));
        }
      } catch (err) {
        console.error(err);
        previewBox.innerHTML = `<div style="padding:16px;color:#ffc7c7">Gagal memuat hasil. Coba aktifkan "Coba Gunakan Proxy" jika perlu.</div>`;
        metaText.textContent = 'Fetch error';
      } finally {
        setLoading(false);
      }
    });

    async function fetchAndPreviewResource(resourceUrl, guessType) {
      try {
        // try fetch the resource (may be blocked if cross-origin)
        const r = await fetch(resourceUrl);
        if (!r.ok) throw new Error('Resource HTTP ' + r.status);
        const blob = await r.blob();
        lastBlob = blob;
        lastIsBlob = true;
        lastUrl = URL.createObjectURL(blob);
        renderPreviewByContentType(r.headers.get('content-type') || guessType, lastUrl);
        enableActions(true);
      } catch (err) {
        // if fetching direct resource fails, fallback: show link only (user can open)
        console.warn('Failed to fetch resource as blob, fallback to link', err);
        lastIsBlob = false;
        lastUrl = resourceUrl;
        previewBox.innerHTML = `<div style="padding:18px;color:var(--muted);text-align:center">Preview tidak tersedia. <br><a href="${escapeHtml(resourceUrl)}" target="_blank" rel="noopener" style="color:var(--accent)">Buka di tab baru</a></div>`;
        enableActions(true);
      }
    }

    function renderPreviewByContentType(ctype, url) {
      if (!ctype) ctype = '';
      if (ctype.startsWith('image/')) {
        previewBox.innerHTML = `<img src="${url}" alt="result image">`;
      } else if (ctype.startsWith('video/')) {
        previewBox.innerHTML = `<video controls src="${url}" style="width:100%"></video>`;
      } else {
        previewBox.innerHTML = `<div style="padding:18px;color:var(--muted);text-align:center">File siap diunduh.</div>`;
      }
    }

    function ctypeGuessFromUrl(u) {
      if (!u) return '';
      if (/\.(png|jpe?g|gif|webp|svg)(\?.*)?$/i.test(u)) return 'image/*';
      if (/\.(mp4|webm|mov)(\?.*)?$/i.test(u)) return 'video/*';
      return '';
    }

    btnDownload.addEventListener('click', async () => {
      const filename = (filenameInput.value || 'downloaded_file').trim();
      if (lastIsBlob && lastBlob) {
        saveBlob(lastBlob, filename);
      } else if (lastUrl) {
        // if lastUrl is remote URL, fetch as blob then save
        try {
          const r = await fetch(lastUrl);
          const b = await r.blob();
          saveBlob(b, filename);
        } catch (err) {
          // fallback: open link
          window.open(lastUrl, '_blank', 'noopener');
        }
      } else {
        alert('Tidak ada file untuk didownload.');
      }
    });

    btnOpen.addEventListener('click', () => {
      if (!lastUrl) return;
      window.open(lastUrl, '_blank', 'noopener');
    });

    btnTryProxy.addEventListener('click', () => {
      useProxy = !useProxy;
      btnTryProxy.textContent = useProxy ? 'Proxy: ON (aktif)' : 'Coba Gunakan Proxy';
      btnTryProxy.style.border = useProxy ? '1px solid rgba(76,201,240,0.18)' : '';
      // if toggled ON, instruct user to click Fetch again
      if (useProxy) {
        alert('Proxy aktif. Tekan Fetch lagi untuk mencoba lewat proxy.');
      }
    });

    // save blob helper
    function saveBlob(blob, filename) {
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
      setTimeout(()=>URL.revokeObjectURL(url), 1500);
    }

    function clearState() {
      lastBlob = null;
      lastUrl = null;
      lastIsBlob = false;
      previewBox.innerHTML = `<div style="text-align:center;color:var(--muted)">Hasil akan muncul di sini</div>`;
      metaText.textContent = '‚Äî';
      btnDownload.style.display = 'none';
      btnOpen.style.display = 'none';
    }
    function enableActions(show) {
      btnDownload.style.display = show ? 'block' : 'none';
      btnOpen.style.display = show ? 'block' : 'none';
    }
    function setLoading(flag) {
      btnFetch.disabled = flag;
      btnFetch.textContent = flag ? 'Working...' : 'Fetch';
    }
    function escapeHtml(s){ return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;'); }

    // intercept fetch to automatically route via proxy if useProxy true
    // (we implement by rebuilding URL before calling fetch)
    // Note: in this version, useProxy affects building fetchUrl (see btnFetch handler)

    // initial
    clearState();
  </script>
</body>
</html>
